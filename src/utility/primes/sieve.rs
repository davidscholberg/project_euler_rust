use super::bounds::prime_count_upper_bound;

/// Iterator that returns an arbitrary number of primes in order.
pub struct Sieve {
    /// The size of the block of numbers we operate the sieve on.
    chunk_size: u64,

    /// The current highest number located at a chunk_size boundary.
    limit: u64,

    /// Bit map of composites and primes that the sieve is currently operating on.
    /// 
    /// 0 means the corresponding index is composite, 1 means it's prime.
    /// 
    /// This will only ever be chunk_size + 1 in size, and accessing the nth
    /// value is done via n % chunk_size.
    composites: Vec<bool>,

    /// List of primes that the sieve has already produced.
    seen_primes: Vec<u64>,

    /// The current prime that the sieve has produced.
    current_prime: u64,
}

impl Sieve {
    /// Create a new rolling sieve at the given chunk size.
    /// 
    /// The sieve will operate on blocks of numbers chunk_size large.
    pub fn new(chunk_size: u64) -> Self {
        Sieve {
            chunk_size,
            limit: chunk_size,
            composites: vec![false; (chunk_size + 1) as usize],
            seen_primes: Vec::with_capacity(prime_count_upper_bound(chunk_size) as usize),
            current_prime: 0
        }
    }

    /// Extends the limit of the sieve to the next chunk_size boundary.
    fn extend_limit(&mut self) {
        let minimum_composite = self.limit + 1;
        self.limit += self.chunk_size;
        for i in 0..self.composites.len() {
            self.composites[i] = false;
        }
        for i in 0..self.seen_primes.len() {
            self.set_multiples_of_prime(self.seen_primes[i], minimum_composite);
        }
    }

    /// Tell if n is composite from composites bit map.
    fn is_composite(&self, n: u64) -> bool {
        self.composites[(n % self.chunk_size) as usize]
    }

    /// Mark n as composite in composites bit map.
    fn set_composite(&mut self, n: u64) {
        self.composites[(n % self.chunk_size) as usize] = true;
    }

    /// Sets multiples of given prime as composites in the current composites chunk.
    fn set_multiples_of_prime(&mut self, prime: u64, minimum: u64) {
        let minimum_multiple = minimum + prime - ((minimum - 1) % prime) - 1;
        let mut multiple = minimum_multiple;
        while multiple <= self.limit {
            self.set_composite(multiple);
            multiple += prime;
        }
    }
}

impl Iterator for Sieve {
    /// Type of the prime numbers returned by this iterator.
    type Item = u64;

    /// Return the next prime number generated by the sieve.
    fn next(&mut self) -> Option<Self::Item> {
        if self.current_prime == 0 {
            self.current_prime = 2;
            self.seen_primes.push(self.current_prime);
            return Some(self.current_prime);
        }
        self.set_multiples_of_prime(self.current_prime, self.current_prime * 2);
        let mut prime_candidate = self.current_prime + 1;
        loop {
            if prime_candidate > self.limit {
                self.extend_limit();
                continue;
            }
            if self.is_composite(prime_candidate) {
                prime_candidate += 1;
                continue;
            }
            self.current_prime = prime_candidate;
            self.seen_primes.push(self.current_prime);
            return Some(self.current_prime);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::Sieve;

    #[test]
    fn test_sieve() {
        assert_eq!(Sieve::new(5).take(4).collect::<Vec<_>>(), [2, 3, 5, 7]);
        assert_eq!(Sieve::new(5).take(5).collect::<Vec<_>>(), [2, 3, 5, 7, 11]);
        assert_eq!(Sieve::new(5).take(6).collect::<Vec<_>>(), [2, 3, 5, 7, 11, 13]);
        assert_eq!(Sieve::new(5).take(20).collect::<Vec<_>>(), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]);
    }
}